from collections import defaultdict
from typing import List, Set, Tuple, Dict
from dataclasses import dataclass
from SCFG_tree import ProductionElement
from nltk import Nonterminal
from typing import List, Set, Tuple, Dict
from dataclasses import dataclass
import logging as log

log.basicConfig(level=log.DEBUG)
log.basicConfig(filename='logs/Parser.log', 
                    filemode='a',
                    level=log.DEBUG, 
                    format='%(asctime)s - %(levelname)s - %(message)s')


@dataclass
class Item:
    """Represents an item in our parsing table spanning (i,j) in first string and (ip,jp) in second string"""
    symbol: str
    i: int    # Start index in first string
    j: int    # End index in first string
    ip: int   # Start index in second string
    jp: int   # End index in second string

class SynchronousCFGParser:
    def __init__(self, grammar: List[Tuple[str, List[ProductionElement], List[ProductionElement]]]):
        """
        Initialize parser with grammar rules.
        Each rule is a tuple of (LHS, RHS1, RHS2) where:
            - LHS is the left-hand side nonterminal symbol
            - RHS1 is the right-hand side for first grammar
            - RHS2 is the right-hand side for second grammar
        """
        self.grammar = grammar
        #self.table: Dict[Tuple[int, int, int, int], Set[str]] = {}
        self.table = defaultdict(lambda: defaultdict(lambda: defaultdict(lambda: defaultdict(set))))
        self.active_spans = set()
        self.nonterminals = {str(rule[0]) for rule in grammar}

    def can_prove_item(self, item: Item, w1: str, w2: str) -> bool:
        """
        Check if we can prove that a nonterminal spans the given indices in both strings.
        This is the core of the synchronous CYK algorithm.
        """
        i, j, ip, jp = item.i, item.j, item.ip, item.jp
        
        # Case 1: Terminal production (span of length 1)
        if j == i + 1 and jp == ip + 1:
            for lhs, rhs1, rhs2 in self.grammar:
                lhs = str(lhs)
                if (lhs == str(item.symbol) and 
                    len(rhs1) == 1 and len(rhs2) == 1 and
                    not rhs1[0].isnonterminal() and not rhs2[0].isnonterminal() and
                    str(rhs1[0].symbol()) == str(w1[i]) and str(rhs2[0].symbol()) == str(w2[ip])):
                    return True

        # Case 2: Binary production (longer spans)
        for k in range(i + 1, j):
            for kp in range(ip + 1, jp):        ## O(n^2) complexity

                for lhs, rhs1, rhs2 in self.grammar:
                    lhs = str(lhs)

                    if lhs != str(item.symbol) or len(rhs1) != 2:
                        continue
                    
                    # rule A → BC in first grammar
                    B1, C1 = rhs1[0], rhs1[1] 

                    # rule A → CB in second grammar
                    B2_pos = next((idx for idx, elem in enumerate(rhs2) 
                                 if str(elem.symbol()) == str(B1.symbol()) and 
                                 str(elem.index()) == str(B1.index())), None)
                    C2_pos = next((idx for idx, elem in enumerate(rhs2) 
                                 if elem.symbol() == C1.symbol() and 
                                 str(elem.index()) == str(C1.index())), None)
                    
                    if B2_pos is None or C2_pos is None:
                        continue
                    
                    # Calculate spans for second string based on ordering
                    # If B comes first in RHS2, it gets (ip,kp), otherwise (kp,jp)
                    B_span2_start = ip if B2_pos == 0 else kp
                    B_span2_end = kp if B2_pos == 0 else jp
                    
                    C_span2_start = ip if C2_pos == 0 else kp
                    C_span2_end = kp if C2_pos == 0 else jp
                    
                    # Check if both spans are proven in our table
                    if (str(B1.symbol()) in self.get_cell(i, k, B_span2_start, B_span2_end) and
                        str(C1.symbol()) in self.get_cell(k, j, C_span2_start, C_span2_end)):
                        return True
        
        return False

    def get_cell(self, i: int, j: int, ip: int, jp: int) -> Set[str]:
        """Safely retrieve items from parsing table."""
        return set(self.table[i][j][ip][jp])

    def parse(self, w1: str, w2: str) -> bool:
        """
        Main parsing algorithm for synchronous CFG.
        Returns True if the string pair can be generated by the grammar.
        """
        n, np = len(w1), len(w2)
        
        # Step 1-2
        # Initialize table with empty sets for each span
        #for i in range(n + 1):
        #    for j in range(i, n + 1):
        #        for ip in range(np + 1):
        #            for jp in range(ip, np + 1):
        #                self.table[(i, j, ip, jp)] = set()

        print(f"Table size:  {len(self.table)}")          

        # Main parsing loop - fill table in order of increasing span size
        for m in range(1, n + np + 1):
            for i in range(n + 1):
                if i < 0:
                    continue
                for k in range(i, min(n + 1, i + m)):
                    if k > n or k < i:
                        continue
                    for ip in range(np + 1):
                        for kp in range(ip, min(np + 1, ip + m)):

                            if kp > np or kp < ip:
                                continue

                            if k - i + kp - ip == m: 
                                for A in self.nonterminals: 
                                    item = Item(A, i, k, ip, kp)
                                    
                                    #if A in self.table[(i, k, ip, kp)]:
                                    if A in self.table[i][k][ip][kp]:
                                        continue
                                    else:
                                        if self.can_prove_item(item, w1, w2):
                                            #self.table[(i, k, ip, kp)].add(A)
                                            self.table[i][k][ip][kp].add(A)
                                            #self.active_spans.add((i, k, ip, kp))
        
        for key in self.table:
            if self.table[key]:
                print(f"Table non-empty cell {key}: {set(self.table[key])}")              

        # Check if we can derive the full strings
        return 'S' in self.get_cell(0, n, 0, np)

def main():
    # Example grammar construction
    g1 = [
        # S -> A{1} B{2} // B{2} A{1}
        ('S', 
        [ProductionElement('A', 1), ProductionElement('B', 2)],
        [ProductionElement('B', 2), ProductionElement('A', 1)]),
        
        # A -> A{1} B{2} // B{2} A{1}
        ('A',
        [ProductionElement('A', 1), ProductionElement('B', 2)],
        [ProductionElement('B', 2), ProductionElement('A', 1)]),
        
        # B -> b // d
        ('B',
        [ProductionElement('b', 0)],
        [ProductionElement('d', 0)]),
        
        # A -> a // c
        ('A',
        [ProductionElement('a', 0)],
        [ProductionElement('c', 0)])
    ]

    g2 = [
        # S -> A{1} B{2} // B{2} A{1}
        ('S', 
        [ProductionElement('A', 1), ProductionElement('B', 2)],
        [ProductionElement('B', 2), ProductionElement('A', 1)]),
        
        # A -> A{1} B{2} // A{1} B{2}
        ('A',
        [ProductionElement('A', 1), ProductionElement('B', 2)],
        [ProductionElement('A', 1), ProductionElement('B', 2)]),
        
        # A -> C{1} F{2} // C{1} F{2}
        ('A',
        [ProductionElement('C', 1), ProductionElement('F', 2)],
        [ProductionElement('C', 1), ProductionElement('F', 2)]),
        
        # B -> B{1} F{2} // F{2} B{1}
        ('B',
        [ProductionElement('B', 1), ProductionElement('F', 2)],
        [ProductionElement('F', 2), ProductionElement('B', 1)]),
        
        # B -> D{1} A{2} // D{1} A{2}
        ('B',
        [ProductionElement('D', 1), ProductionElement('A', 2)],
        [ProductionElement('D', 1), ProductionElement('A', 2)]),
        
        # C -> C{1} D{2} // D{2} C{1}
        ('C',
        [ProductionElement('C', 1), ProductionElement('D', 2)],
        [ProductionElement('D', 2), ProductionElement('C', 1)]),
        
        # C -> F{1} B{2} // B{2} F{1}
        ('C',
        [ProductionElement('F', 1), ProductionElement('B', 2)],
        [ProductionElement('B', 2), ProductionElement('F', 1)]),
        
        # D -> F{1} A{2} // F{1} A{2}
        ('D',
        [ProductionElement('F', 1), ProductionElement('A', 2)],
        [ProductionElement('F', 1), ProductionElement('A', 2)]),
        
        # D -> D{1} C{2} // D{1} C{2}
        ('D',
        [ProductionElement('D', 1), ProductionElement('C', 2)],
        [ProductionElement('D', 1), ProductionElement('C', 2)]),
        
        # F -> D{1} B{2} // B{2} D{1}
        ('F',
        [ProductionElement('D', 1), ProductionElement('B', 2)],
        [ProductionElement('B', 2), ProductionElement('D', 1)]),
        
        # F -> F{1} C{2} // C{2} F{1}
        ('F',
        [ProductionElement('F', 1), ProductionElement('C', 2)],
        [ProductionElement('C', 2), ProductionElement('F', 1)]),
        
        # Terminal productions for A
        ('A',
        [ProductionElement('a', 0)],
        [ProductionElement('e', 0)]),
        
        ('A',
        [ProductionElement('b', 0)],
        [ProductionElement('f', 0)]),
        
        ('A',
        [ProductionElement('a', 0)],
        [ProductionElement('g', 0)]),
        
        # Terminal productions for B
        ('B',
        [ProductionElement('b', 0)],
        [ProductionElement('f', 0)]),
        
        ('B',
        [ProductionElement('a', 0)],
        [ProductionElement('e', 0)]),
        
        # Terminal productions for C
        ('C',
        [ProductionElement('c', 0)],
        [ProductionElement('g', 0)]),
        
        ('C',
        [ProductionElement('d', 0)],
        [ProductionElement('h', 0)]),
        
        # Terminal productions for D
        ('D',
        [ProductionElement('d', 0)],
        [ProductionElement('h', 0)]),
        
        ('D',
        [ProductionElement('c', 0)],
        [ProductionElement('g', 0)]),
        
        # Terminal productions for F
        ('F',
        [ProductionElement('c', 0)],
        [ProductionElement('g', 0)]),
        
        ('F',
        [ProductionElement('a', 0)],
        [ProductionElement('e', 0)])
    ]

    import time

    start = time.time()
    parser2 = SynchronousCFGParser(g2)
    result1 = parser2.parse("cbaaba", "aaaaaa")  # Should return False
    print(f"Result1: {result1}")
    end = time.time()
    log.info(f"Time taken to parse the string: {end-start} seconds")

    start = time.time()
    result2 = parser2.parse("cbaaba", "efgeef")  # Should return True
    print(f"Result2: {result2}")
    end = time.time()
    log.info(f"Time taken to parse the string: {end-start} seconds")

    start = time.time()
    result3 = parser2.parse("aabccaddadcbaddaccbda", "eeehgfgehhefghehheggf")  # Should return True
    print(f"Result3: {result3}")
    end = time.time()
    log.info(f"Time taken to parse the string: {end-start} seconds")

if __name__ == "__main__":
    main()