from typing import List, Set, Tuple, Dict
from dataclasses import dataclass
from SCFG_tree import ProductionElement
from nltk import Nonterminal

from typing import List, Set, Tuple, Dict
from dataclasses import dataclass

@dataclass
class Item:
    """Represents an item in our parsing table spanning (i,j) in first string and (ip,jp) in second string"""
    symbol: str
    i: int    # Start index in first string
    j: int    # End index in first string
    ip: int   # Start index in second string
    jp: int   # End index in second string

class SynchronousCFGParser:
    def __init__(self, grammar: List[Tuple[str, List[ProductionElement], List[ProductionElement]]]):
        """
        Initialize parser with grammar rules.
        Each rule is a tuple of (LHS, RHS1, RHS2) where:
            - LHS is the left-hand side nonterminal symbol
            - RHS1 is the right-hand side for first grammar
            - RHS2 is the right-hand side for second grammar
        """
        self.grammar = grammar
        self.table: Dict[Tuple[int, int, int, int], Set[str]] = {}
        
        # Extract all nonterminals for efficiency
        self.nonterminals = {str(rule[0]) for rule in grammar}

    def can_prove_item(self, item: Item, w1: str, w2: str) -> bool:
        """
        Check if we can prove that a nonterminal spans the given indices in both strings.
        This is the core of the synchronous CYK algorithm.
        """
        i, j, ip, jp = item.i, item.j, item.ip, item.jp
        
        # Case 1: Terminal production (span of length 1)
        if j == i + 1 and jp == ip + 1:
            # Look for terminal productions that match our input
            for lhs, rhs1, rhs2 in self.grammar:
                lhs = str(lhs)

                if (lhs == str(item.symbol) and 
                    len(rhs1) == 1 and len(rhs2) == 1 and
                    not rhs1[0].isnonterminal() and not rhs2[0].isnonterminal() and
                    str(rhs1[0].symbol()) == str(w1[i]) and str(rhs2[0].symbol()) == str(w2[ip])):
                    return True

        # Case 2: Binary production (longer spans)
        for k in range(i + 1, j):
            for kp in range(ip + 1, jp):
                # Check each grammar rule
                for lhs, rhs1, rhs2 in self.grammar:
                    lhs = str(lhs)
                    # Skip if this isn't a binary production or wrong LHS
                    if lhs != str(item.symbol) or len(rhs1) != 2:
                        continue
                    
                    # We're looking for a rule A â†’ BC with potential reordering
                    B1, C1 = rhs1[0], rhs1[1]  # Elements in first grammar

                    # Find corresponding elements in second grammar by matching indices
                    B2_pos = next((idx for idx, elem in enumerate(rhs2) 
                                 if str(elem.symbol()) == str(B1.symbol()) and 
                                 str(elem.index()) == str(B1.index())), None)
                    C2_pos = next((idx for idx, elem in enumerate(rhs2) 
                                 if elem.symbol() == C1.symbol() and 
                                 str(elem.index()) == str(C1.index())), None)
                    
                    if B2_pos is None or C2_pos is None:
                        continue
                    
                    # Calculate spans for second string based on ordering
                    # If B comes first in RHS2, it gets (ip,kp), otherwise (kp,jp)
                    B_span2_start = ip if B2_pos == 0 else kp
                    B_span2_end = kp if B2_pos == 0 else jp
                    
                    C_span2_start = ip if C2_pos == 0 else kp
                    C_span2_end = kp if C2_pos == 0 else jp
                    
                    # Check if both spans are proven in our table
                    if (str(B1.symbol()) in self.get_cell(i, k, B_span2_start, B_span2_end) and
                        str(C1.symbol()) in self.get_cell(k, j, C_span2_start, C_span2_end)):
                        return True
        
        return False

    def get_cell(self, i: int, j: int, ip: int, jp: int) -> Set[str]:
        """Safely retrieve items from parsing table."""
        return self.table.get((i, j, ip, jp), set())

    def parse(self, w1: str, w2: str) -> bool:
        """
        Main parsing algorithm for synchronous CFG.
        Returns True if the string pair can be generated by the grammar.
        """
        n, np = len(w1), len(w2)
        
        # Initialize empty table
        for i in range(n + 1):
            for j in range(i, n + 1):
                for ip in range(np + 1):
                    for jp in range(ip, np + 1):
                        self.table[(i, j, ip, jp)] = set()

        # Main parsing loop - fill table in order of increasing span size
        for m in range(1, n + np + 1):
            for i in range(n + 1):
                for k in range(i, min(n + 1, i + m)):
                    for ip in range(np + 1):
                        for kp in range(ip, min(np + 1, ip + m)):
                            # Check if spans satisfy the size constraint
                            if k - i + kp - ip == m:
                                # Try to prove items for each nonterminal
                                for A in self.nonterminals:
                                    item = Item(A, i, k, ip, kp)
                                    if self.can_prove_item(item, w1, w2):
                                        self.table[(i, k, ip, kp)].add(A)

        # Check if we can derive the full strings
        return 'S' in self.get_cell(0, n, 0, np)

def main():
    # Example grammar construction
    g1 = [
        # S -> A{1} B{2} // B{2} A{1}
        ('S', 
        [ProductionElement('A', 1), ProductionElement('B', 2)],
        [ProductionElement('B', 2), ProductionElement('A', 1)]),
        
        # A -> A{1} B{2} // B{2} A{1}
        ('A',
        [ProductionElement('A', 1), ProductionElement('B', 2)],
        [ProductionElement('B', 2), ProductionElement('A', 1)]),
        
        # B -> b // d
        ('B',
        [ProductionElement('b', 0)],
        [ProductionElement('d', 0)]),
        
        # A -> a // c
        ('A',
        [ProductionElement('a', 0)],
        [ProductionElement('c', 0)])
    ]

    g2 = [
        # S -> A{1} B{2} // B{2} A{1}
        ('S', 
        [ProductionElement('A', 1), ProductionElement('B', 2)],
        [ProductionElement('B', 2), ProductionElement('A', 1)]),
        
        # A -> A{1} B{2} // A{1} B{2}
        ('A',
        [ProductionElement('A', 1), ProductionElement('B', 2)],
        [ProductionElement('A', 1), ProductionElement('B', 2)]),
        
        # A -> C{1} F{2} // C{1} F{2}
        ('A',
        [ProductionElement('C', 1), ProductionElement('F', 2)],
        [ProductionElement('C', 1), ProductionElement('F', 2)]),
        
        # B -> B{1} F{2} // F{2} B{1}
        ('B',
        [ProductionElement('B', 1), ProductionElement('F', 2)],
        [ProductionElement('F', 2), ProductionElement('B', 1)]),
        
        # B -> D{1} A{2} // D{1} A{2}
        ('B',
        [ProductionElement('D', 1), ProductionElement('A', 2)],
        [ProductionElement('D', 1), ProductionElement('A', 2)]),
        
        # C -> C{1} D{2} // D{2} C{1}
        ('C',
        [ProductionElement('C', 1), ProductionElement('D', 2)],
        [ProductionElement('D', 2), ProductionElement('C', 1)]),
        
        # C -> F{1} B{2} // B{2} F{1}
        ('C',
        [ProductionElement('F', 1), ProductionElement('B', 2)],
        [ProductionElement('B', 2), ProductionElement('F', 1)]),
        
        # D -> F{1} A{2} // F{1} A{2}
        ('D',
        [ProductionElement('F', 1), ProductionElement('A', 2)],
        [ProductionElement('F', 1), ProductionElement('A', 2)]),
        
        # D -> D{1} C{2} // D{1} C{2}
        ('D',
        [ProductionElement('D', 1), ProductionElement('C', 2)],
        [ProductionElement('D', 1), ProductionElement('C', 2)]),
        
        # F -> D{1} B{2} // B{2} D{1}
        ('F',
        [ProductionElement('D', 1), ProductionElement('B', 2)],
        [ProductionElement('B', 2), ProductionElement('D', 1)]),
        
        # F -> F{1} C{2} // C{2} F{1}
        ('F',
        [ProductionElement('F', 1), ProductionElement('C', 2)],
        [ProductionElement('C', 2), ProductionElement('F', 1)]),
        
        # Terminal productions for A
        ('A',
        [ProductionElement('a', 0)],
        [ProductionElement('e', 0)]),
        
        ('A',
        [ProductionElement('b', 0)],
        [ProductionElement('f', 0)]),
        
        ('A',
        [ProductionElement('a', 0)],
        [ProductionElement('g', 0)]),
        
        # Terminal productions for B
        ('B',
        [ProductionElement('b', 0)],
        [ProductionElement('f', 0)]),
        
        ('B',
        [ProductionElement('a', 0)],
        [ProductionElement('e', 0)]),
        
        # Terminal productions for C
        ('C',
        [ProductionElement('c', 0)],
        [ProductionElement('g', 0)]),
        
        ('C',
        [ProductionElement('d', 0)],
        [ProductionElement('h', 0)]),
        
        # Terminal productions for D
        ('D',
        [ProductionElement('d', 0)],
        [ProductionElement('h', 0)]),
        
        ('D',
        [ProductionElement('c', 0)],
        [ProductionElement('g', 0)]),
        
        # Terminal productions for F
        ('F',
        [ProductionElement('c', 0)],
        [ProductionElement('g', 0)]),
        
        ('F',
        [ProductionElement('a', 0)],
        [ProductionElement('e', 0)])
    ]

    #parser1 = SynchronousCFGParser(g1)
    #result1 = parser1.parse("abbbb", "ddddc")  # Should return True

    parser2 = SynchronousCFGParser(g2)
    result2 = parser2.parse("cdccaabbcab", "fgfhgeegegf")  # Should return False

    print(result2)